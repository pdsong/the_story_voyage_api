defmodule TheStoryVoyageApi.StatsTest do
  use TheStoryVoyageApi.DataCase

  alias TheStoryVoyageApi.Stats
  alias TheStoryVoyageApi.Accounts
  import TheStoryVoyageApi.AccountsFixtures
  import TheStoryVoyageApi.BooksFixtures
  import TheStoryVoyageApi.Books

  describe "stats" do
    test "get_overview/1 returns correct aggregation" do
      user = user_fixture()
      book1 = book_fixture(%{"pages" => 100})
      book2 = book_fixture(%{"pages" => 200})

      Accounts.track_book(user, book1.id, %{status: "read", rating: 5.0})
      Accounts.track_book(user, book2.id, %{status: "reading"})

      stats = Stats.get_overview(user.id)

      assert stats.read_count == 1
      assert stats.reading_count == 1
      assert stats.total_pages_read == 100
      assert stats.average_rating == 5.0
    end

    test "get_year_stats/2 returns correct year data" do
      user = user_fixture()
      # Ensure books are created with specific dates?
      # track_book uses timestamps(). We can't easily override updated_at via track_book unless we manipulate repo directly or use a helper.
      # But inserted_at/updated_at are autogenerated.
      # We can update them manually after insertion.

      book1 = book_fixture(%{"pages" => 100})
      {:ok, ub1} = Accounts.track_book(user, book1.id, %{status: "read", rating: 4.0})

      # Manually set updated_at to 2025
      {:ok, _} =
        Repo.query("UPDATE user_books SET updated_at = '2025-05-15 10:00:00' WHERE id = $1", [
          ub1.id
        ])

      book2 = book_fixture(%{"pages" => 200})
      {:ok, ub2} = Accounts.track_book(user, book2.id, %{status: "read", rating: 5.0})
      # Manually set updated_at to 2026 (current year or specific test year)
      {:ok, _} =
        Repo.query("UPDATE user_books SET updated_at = '2026-01-10 10:00:00' WHERE id = $1", [
          ub2.id
        ])

      # Stats for 2025
      stats2025 = Stats.get_year_stats(user.id, 2025)
      assert stats2025.book_count == 1
      assert stats2025.page_count == 100
      assert stats2025.average_rating == 4.0
      may_entry = Enum.find(stats2025.monthly_timeline, &(&1.month == 5))
      jan_entry = Enum.find(stats2025.monthly_timeline, &(&1.month == 1))

      assert may_entry.count == 1
      assert jan_entry.count == 0

      # Stats for 2026
      stats2026 = Stats.get_year_stats(user.id, 2026)
      assert stats2026.book_count == 1
      assert stats2026.page_count == 200
    end

    test "get_genre_distribution/1 returns correct percentages" do
      user = user_fixture()
      {:ok, genre1} = create_genre(%{name: "Sci-Fi", slug: "sci-fi"})
      {:ok, genre2} = create_genre(%{name: "Fantasy", slug: "fantasy"})

      book1 = book_fixture(%{"genre_ids" => [genre1.id]})
      book2 = book_fixture(%{"genre_ids" => [genre1.id]})
      book3 = book_fixture(%{"genre_ids" => [genre2.id]})

      Accounts.track_book(user, book1.id, %{status: "read"})
      Accounts.track_book(user, book2.id, %{status: "read"})
      Accounts.track_book(user, book3.id, %{status: "read"})

      dist = Stats.get_genre_distribution(user.id)

      # Total 3 "genre instances" (each book has 1 genre here).
      # Sci-Fi: 2 (66.6%), Fantasy: 1 (33.3%)

      sci_fi = Enum.find(dist, &(&1.name == "Sci-Fi"))
      fantasy = Enum.find(dist, &(&1.name == "Fantasy"))

      assert sci_fi.count == 2
      assert_in_delta sci_fi.percentage, 66.66, 0.1

      assert fantasy.count == 1
      assert_in_delta fantasy.percentage, 33.33, 0.1
    end

    test "get_mood_distribution/1" do
      user = user_fixture()
      {:ok, mood} = create_mood(%{name: "Dark", slug: "dark"})
      book = book_fixture(%{"mood_ids" => [mood.id]})

      Accounts.track_book(user, book.id, %{status: "read"})

      dist = Stats.get_mood_distribution(user.id)
      entry = List.first(dist)

      assert entry.name == "Dark"
      assert entry.count == 1
      assert entry.percentage == 100.0
    end
  end
end
